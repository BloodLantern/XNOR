//------------------------------------------------------------------------------
// <auto-generated />
//
// This file was automatically generated by SWIG (https://www.swig.org).
// Version 4.2.1
//
// Do not make changes to this file unless you know what you are doing - modify
// the SWIG interface file instead.
//------------------------------------------------------------------------------

namespace Xnor.Core {

public class Transform : global::System.IDisposable {
  private global::System.Runtime.InteropServices.HandleRef swigCPtr;
  protected bool swigCMemOwn;

  internal Transform(global::System.IntPtr cPtr, bool cMemoryOwn) {
    swigCMemOwn = cMemoryOwn;
    swigCPtr = new global::System.Runtime.InteropServices.HandleRef(this, cPtr);
  }

  internal static global::System.Runtime.InteropServices.HandleRef getCPtr(Transform obj) {
    return (obj == null) ? new global::System.Runtime.InteropServices.HandleRef(null, global::System.IntPtr.Zero) : obj.swigCPtr;
  }

  internal static global::System.Runtime.InteropServices.HandleRef swigRelease(Transform obj) {
    if (obj != null) {
      if (!obj.swigCMemOwn)
        throw new global::System.ApplicationException("Cannot release ownership as memory is not owned");
      global::System.Runtime.InteropServices.HandleRef ptr = obj.swigCPtr;
      obj.swigCMemOwn = false;
      obj.Dispose();
      return ptr;
    } else {
      return new global::System.Runtime.InteropServices.HandleRef(null, global::System.IntPtr.Zero);
    }
  }

  ~Transform() {
    Dispose(false);
  }

  public void Dispose() {
    Dispose(true);
    global::System.GC.SuppressFinalize(this);
  }

  protected virtual void Dispose(bool disposing) {
    lock(this) {
      if (swigCPtr.Handle != global::System.IntPtr.Zero) {
        if (swigCMemOwn) {
          swigCMemOwn = false;
          CoreCNative.delete_Transform(swigCPtr);
        }
        swigCPtr = new global::System.Runtime.InteropServices.HandleRef(null, global::System.IntPtr.Zero);
      }
    }
  }

  public Matrix worldMatrix {
    set {
      CoreCNative.Transform_worldMatrix_set(swigCPtr,  ref value );
    } 
		get { 
			nint ptr = CoreCNative.Transform_worldMatrix_get(swigCPtr);
			Matrix ret = (Matrix) global::System.Runtime.InteropServices.Marshal.PtrToStructure(ptr, typeof(Matrix));
			return ret;
		}
	
  }

  public  Vector3  GetPosition() {
		nint ptr = CoreCNative.Transform_GetPosition(swigCPtr);
		Vector3 ret = (Vector3) global::System.Runtime.InteropServices.Marshal.PtrToStructure(ptr, typeof(Vector3));
		return ret;
	}

  public void SetPosition( Vector3  newPosition) {
    CoreCNative.Transform_SetPosition(swigCPtr,  ref newPosition );
  }

  public void SetPositionX(float newPositionX) {
    CoreCNative.Transform_SetPositionX(swigCPtr, newPositionX);
  }

  public void SetPositionY(float newPositionY) {
    CoreCNative.Transform_SetPositionY(swigCPtr, newPositionY);
  }

  public void SetPositionZ(float newPositionZ) {
    CoreCNative.Transform_SetPositionZ(swigCPtr, newPositionZ);
  }

  public  Vector3  GetRotationEulerAngle() {
		nint ptr = CoreCNative.Transform_GetRotationEulerAngle(swigCPtr);
		Vector3 ret = (Vector3) global::System.Runtime.InteropServices.Marshal.PtrToStructure(ptr, typeof(Vector3));
		return ret;
	}

  public void SetRotationEulerAngle( Vector3  newRotationEulerAngle) {
    CoreCNative.Transform_SetRotationEulerAngle(swigCPtr,  ref newRotationEulerAngle );
  }

  public void SetRotationEulerAngleX(float newRotationEulerAngleX) {
    CoreCNative.Transform_SetRotationEulerAngleX(swigCPtr, newRotationEulerAngleX);
  }

  public void SetRotationEulerAngleY(float newRotationEulerAngleY) {
    CoreCNative.Transform_SetRotationEulerAngleY(swigCPtr, newRotationEulerAngleY);
  }

  public void SetRotationEulerAngleZ(float newRotationEulerAngleZ) {
    CoreCNative.Transform_SetRotationEulerAngleZ(swigCPtr, newRotationEulerAngleZ);
  }

  public  Quaternion  GetRotation() {
		nint ptr = CoreCNative.Transform_GetRotation(swigCPtr);
		Quaternion ret = (Quaternion) global::System.Runtime.InteropServices.Marshal.PtrToStructure(ptr, typeof(Quaternion));
		return ret;
	}

  public void SetRotation( Quaternion  newRotation) {
    CoreCNative.Transform_SetRotation(swigCPtr,  ref newRotation );
  }

  public void SetRotationX(float newRotationX) {
    CoreCNative.Transform_SetRotationX(swigCPtr, newRotationX);
  }

  public void SetRotationY(float newRotationY) {
    CoreCNative.Transform_SetRotationY(swigCPtr, newRotationY);
  }

  public void SetRotationZ(float newRotationZ) {
    CoreCNative.Transform_SetRotationZ(swigCPtr, newRotationZ);
  }

  public void SetRotationW(float newRotationW) {
    CoreCNative.Transform_SetRotationW(swigCPtr, newRotationW);
  }

  public  Vector3  GetScale() {
		nint ptr = CoreCNative.Transform_GetScale(swigCPtr);
		Vector3 ret = (Vector3) global::System.Runtime.InteropServices.Marshal.PtrToStructure(ptr, typeof(Vector3));
		return ret;
	}

  public void SetScale( Vector3  newScale) {
    CoreCNative.Transform_SetScale(swigCPtr,  ref newScale );
  }

  public void SetScaleX(float newScaleX) {
    CoreCNative.Transform_SetScaleX(swigCPtr, newScaleX);
  }

  public void SetScaleY(float newScaleY) {
    CoreCNative.Transform_SetScaleY(swigCPtr, newScaleY);
  }

  public void SetScaleZ(float newScaleZ) {
    CoreCNative.Transform_SetScaleZ(swigCPtr, newScaleZ);
  }

  public bool GetChanged() {
    bool ret = CoreCNative.Transform_GetChanged(swigCPtr);
    return ret;
  }

  public  Vector3  GetRight() {
			Vector3 ret = CoreCNative.Transform_GetRight(swigCPtr);
			return ret;
		}

  public  Vector3  GetUp() {
			Vector3 ret = CoreCNative.Transform_GetUp(swigCPtr);
			return ret;
		}

  public  Vector3  GetForward() {
			Vector3 ret = CoreCNative.Transform_GetForward(swigCPtr);
			return ret;
		}

  public Transform() : this(CoreCNative.new_Transform(), true) {
  }

}

}
